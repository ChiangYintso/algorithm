# 数学

## 快速幂/快速幂取模/费马小定理

快速幂

```c++
long long fast_pow(long long base, long long idx) {
    if (base == 0) return 0;
    long long result = 1;
    while (idx > 0) {
        if (idx & 1) result *= base;
        base *= base;
        idx >>= 1;
    }
    return result;
}
```

快速幂取模

```c++
long long fast_pow(long long base, long long idx, long long mod) {
    if (base == 0 || mod == 1) return 0;
    long long result = 1;
    base %= mod;
    while (idx > 0) {
        if (idx & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        idx >>= 1;
    }
    return result;
}
```

费马小定理：若p为素数，gcd(a, p) = 1，则$a^{p-1} \equiv 1 \pmod p$

因此当a和p互质且p为素数时，可以计算$a^{x}\bmod p=a^{x\bmod(p-1)} \bmod p$ 来提高效率。

## 乘法逆元

若线性同余方程$ax\equiv1\pmod b$，则称x为$a\bmod b$ 的逆元，记作$a^{-1}$

快速幂+费马小定理求逆元：b为素数时，逆元$x=a^{b-2}$

$\frac a b$为分数，求$a*b^{-1} \bmod p$
$$
a*b^{-1} \equiv a * b^{p-2}\pmod p
$$

## 组合数学

组合数打表

$\mathrm C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$

```c++
long long C[1009][1009];

void init() {
    for (int n = 0; n <= 1003; ++n) {
        C[n][0] = C[n][n] = 1;
        for (int m = 1; m < n; ++m) {
            C[n][m] = C[n - 1][m] + C[n - 1][m - 1];
        }
    }
}
```

## 常数

PI = 3.14159265358979323846