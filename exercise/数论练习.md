# 数论练习

[TOC]

## 素数筛

luogup1835 求【L， R】间的素数个数

```c++
//
// Created by jiang on 2020/8/16.
//

#include <cstdio>
#include <bitset>
#include <vector>

std::bitset<46342> is_prime;
std::bitset<1000001> is_comp;
std::vector<long long> primes;

void thieve() {
    is_prime.flip();
    for (int i = 2; i <= 46341; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i; j <= 46341; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

int main() {
    thieve();
    long long l, r;
    scanf("%lld %lld", &l, &r);
    if (l == 1) l = 2;
    for (auto &i : primes) {
        if (i * i > r) break;
        for (long long j = std::max(i << 1, (l + i - 1) / i * i); j <= r; j += i)
            is_comp[j - l] = true;
    }
    printf("%llu\n", r - l + 1 - is_comp.count());
    return 0;
}
```

## GCD、LCM

https://www.luogu.com.cn/problem/P1414

从n个数中取出1、2、3、...、n个数，使其gcd最大。

解：求出每个因数出现的次数，并对每个次数记录最大的因数。

```c++
#include <cstdio>

int arr[100009];
int prime_count[1000009] = {0};
int answer[1000009] = {0};

inline int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", arr + i);
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 1; j * j <= arr[i]; ++j) {
            if (arr[i] % j == 0) {
                prime_count[j]++;
                answer[prime_count[j]] = max(answer[prime_count[j]], j);
                if (j * j < arr[i]) {
                    prime_count[arr[i] / j]++;
                    answer[prime_count[arr[i] / j]] = max(answer[prime_count[arr[i] / j]], arr[i] / j);
                }
            }
        }
    }

    for (int i = 1; i <= n; ++i)
        printf("%d\n", answer[i]);

    return 0;
}

```

**hdu5656 求n个数所有挑选组合的gcd之和（gcd+dp）**

```c++
//
// Created by Jiang Yinzuo on 2020/7/17.
//

#include <cstdio>
#include <algorithm>
#include <cstring>

const int MOD = 100000007;
long long dp[1001][1001];
int arr[1001];
int gcd[1001][1001] = {0};

void get_gcd(int n, int m) {
    for (int i = 1; i <= 1000; ++i) {
        for (int j = 1; j <= 1000; ++j) {
            if (!gcd[i][j]) {
                for (int k = 1; k * i <= n && k * j <= m; ++k) {
                    gcd[k * i][k * j] = k;
                }
            }
        }
    }
}

void solve(int n, int max_gcd) {
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= n; ++i) {
        dp[i][arr[i]] = 1;
        for (int j = 1; j <= max_gcd; ++j) {
            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;
            dp[i][gcd[arr[i]][j]] = (dp[i][gcd[arr[i]][j]] + dp[i - 1][j]) % MOD;
        }
    }

    long long answer = 0;
    for (int i = 1; i <= max_gcd; ++i) {
        answer = (answer + dp[n][i] * i) % MOD;
    }
    printf("%lld\n", answer);
}

int main() {
    get_gcd(1000, 1000);
    int t;
    scanf("%d", &t);
    while (t--) {
        int n;
        scanf("%d", &n);
        int max_gcd = 0;
        for (int i = 1; i <= n; ++i) {
            scanf("%d", arr + i);
            max_gcd = std::max(max_gcd, arr[i]);
        }
        solve(n, max_gcd);
    }
    return 0;
}

```



**cf1366D 对正整数a，找到a的大于1的因数b，c使得$$\gcd(b+c,a)=1$$**

解：若$$\gcd(b, c) = g > 1$$，则$$b+c和a$$至少有g这个公因数。故仅当存在$$\gcd(b, c) = 1$$时，问题有解。

$$gcd(b, c) = 1 \iff gcd(b+c, c) = 1 \iff gcd(b+c,b) = 1 \iff \gcd(b+c, cb^k) = 1$$。故找到a的最小质因数$$p$$（提前打表），解为$$b = p^k, c = \frac{a}{p^k}, c\bmod b \neq 0 $$

```c++
//
// Created by Jiang Yinzuo on 2020/7/23.
//

#include <vector>
#include <cstdio>

int min_prime[10000007] = {0};

void get_min_prime_factor() {
    for (int i = 2; i <= 3163; ++i) {
        if (min_prime[i] == 0) {
            for (int j = i * 2; j <= 10000000; j += i) {
                if (min_prime[j] == 0)
                    min_prime[j] = i;
            }
        }
    }
}

std::vector<int> b_ans, c_ans;

void solve(int a) {
    if (min_prime[a] == 0) {
        b_ans.push_back(-1);
        c_ans.push_back(-1);
        return;
    }
    int c = a;
    while (c % min_prime[a] == 0) {
        c /= min_prime[a];
    }
    if (c > 1) {
        b_ans.push_back(min_prime[a]);
        c_ans.push_back(c);
    } else {
        b_ans.push_back(-1);
        c_ans.push_back(-1);
    }
}

int main() {
    get_min_prime_factor();
    int n;
    scanf("%d", &n);
    int a;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a);
        solve(a);
    }
    for (auto &i : b_ans) {
        printf("%d ", i);
    }
    puts("");
    for (auto &i : c_ans) {
        printf("%d ", i);
    }
    puts("");
    return 0;
}
```



## 因数个数定理

**hdu6069**：求
$$
(∑\limits_{i=l}^rd(i^k)) \bmod998244353 \space \space \space (1≤l≤r≤10^{12},r−l≤10^6,1≤k≤10^7).
$$
$$d(x)$$表示x的因数个数。

显然，1e6以上的质数最多存在一个。故先打表得到1-1e6之间的质数。枚举1-1e6中的每个质数。根据该质数在【l, r】中的出现的次数更新$$d(i^k)$$，并将i /= 质数。质数^2大于r时停止遍历。

```c++
//
// Created by Jiang Yinzuo on 2020/7/17.
//

#include <cstdio>
#include <vector>
#include <cstring>

const int MOD = 998244353;
bool is_prime[1000006];
std::vector<int> primes;

void sieve(int n) {
    memset(is_prime, true, sizeof(is_prime));
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i + i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

void solve(long long l, long long r, long long k) {
    static long long num[1000006];
    static long long factor_count[1000006];
    for (long long i = l; i <= r; ++i) {
        num[i - l] = i;
        factor_count[i - l] = 1;
    }

    for (auto &prime : primes) {
        if (prime * prime > r) break;
        long long i = (long long) (l / prime) * prime;
        while (i < l) i += prime;
        for (; i <= r; i += prime) {
            long long count = 0;
            while (num[i - l] % prime == 0) {
                num[i - l] /= prime;
                count++;
            }
            factor_count[i - l] = factor_count[i - l] * (count * k + 1) % MOD;
        }
    }

    long long answer = 0;
    for (long long i = l; i <= r; ++i) {
        if (num[i - l] == 1)
            answer = (answer + factor_count[i - l]) % MOD;
        else answer = (answer + factor_count[i - l] * (k + 1) % MOD) % MOD;
    }
    printf("%lld\n", answer);
}

int main() {
    sieve(1000005);
    int t;
    scanf("%d", &t);
    while (t--) {
        long long l, r, k;
        scanf("%lld %lld %lld", &l, &r, &k);
        solve(l, r, k);
    }
    return 0;
}

```

**南京2018 J**

```c++
//
// Created by jiang on 2020/9/22.
//

#include <cstdio>
#include <vector>
#include <unordered_map>

constexpr int MAX_N = 1000009;

std::vector<long long> primes;

void euler_thieve() {
    static bool not_prime[MAX_N] = {false};
    for (int i = 2; i * i < MAX_N; i++) {
        if (!not_prime[i]) {
            primes.push_back(i);
        }
        for (int j = 0; j < primes.size() && i * primes[j] < MAX_N; ++j) {
            not_prime[i * primes[j]] = true;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

std::unordered_map<int, std::vector<long long>> factor_pos;

void factor(int x, int pos) {
    // c++11能用for-range循环
    for (int i = 0; i < primes.size() && primes[i] * primes[i] <= x; ++i) {
        if (x % primes[i] == 0) {
            factor_pos[primes[i]].push_back(pos);
            do {
                x /= primes[i];
            } while (x % primes[i] == 0);
        }
    }
    if (x > 1) factor_pos[x].push_back(pos);
}

int main() {
    euler_thieve();
    int n, a;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a);
        factor(a, i);
    }
    long long ans = 0;
    for (auto &i : factor_pos) {
        ans += i.second[0] * (n - i.second[0] + 1);
        for (int j = 1; j < i.second.size(); ++j) {
            ans += (i.second[j] - i.second[j - 1]) * (n - i.second[j] + 1);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```



## pollard_rho

```c++
//
// Created by jiang on 2020/8/15.
// 徐州ICPC2019 multiply

#include <cstdio>
#include <ctime>
#include <algorithm>
#include <map>

#define TEST_TIMES 8 // 米勒罗宾素性测试次数

std::map<long long, long long> factor_nums;

/**
 * 快速乘法
 * @param a
 * @param b
 * @param p
 * @return
 */
long long mul(long long a, long long b, long long p) {
    long long ans = 0;
    a %= p;
    while (b) {
        if (b & 1)ans = (ans + a) % p;
        b /= 2;
        a = (a + a) % p;
    }
    return ans;
}

/**
 * 快速幂取模
 * @param a
 * @param b
 * @param p
 * @return
 */
long long pow(long long a, long long b, long long p) {
    long long ans = 1;
    a %= p;
    while (b) {
        if (b & 1) ans = mul(a, ans, p);
        b /= 2;
        a = mul(a, a, p);
    }
    ans %= p;
    return ans;
}

/**
 * 米勒罗宾素性测试
 * @param n 测试的大数
 * @param repeat 测试重复次数
 * @return 大概率是素数：true；不是素数：false
 */
bool miller_rabin(long long n, int repeat) {
    if (n == 2 || n == 3)return true;//特判
    if (n % 2 == 0 || n == 1)return false;//偶数和1

    //将n-1分解成2^s*d
    long long d = n - 1;
    int s = 0;
    while (!(d & 1)) ++s, d >>= 1;
    //srand((unsigned)time(NULL));在最开始调用即可
    for (int i = 0; i < repeat; i++)//重复repeat次
    {
        long long a = rand() % (n - 3) + 2;//取一个随机数,[2,n-1)
        long long x = pow(a, d, n);
        long long y = 0;
        for (int j = 0; j < s; j++) {
            y = mul(x, x, n);
            if (y == 1 && x != 1 && x != (n - 1))return false;
            x = y;
        }
        if (y != 1)return false; //费马小定理
    }
    return true;
}

long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}

/**
 * 找到n的一个因子
 * @param n
 * @param c
 * @return
 */
long long pollard_rho(long long n, long long c) {
    long long x = rand() % (n - 2) + 1;
    long long y = x, i = 1, k = 2;
    for (;;) {
        i++;
        x = (mul(x, x, n) + c) + n;//不断调整x2
        long long d = gcd(y - x, n);
        if (1 < d && d < n)
            return d;//找到因子
        if (y == x)
            return n;//找到循环，返回n，重新来
        if (i == k) { //一个优化
            y = x;
            k <<= 1;
        }
    }
}

void find_factor(long long n, long long c) {
    if (n == 1)return;//递归出口

    if (miller_rabin(n, TEST_TIMES)) { //如果是素数，就加入
        factor_nums[n]++;
        return;
    }

    long long p = n;
    while (p >= n)
        p = pollard_rho(p, c--);//不断找因子，知道找到为止，返回n说明没找到

    find_factor(p, c);
    find_factor(n / p, c);
}

long long arr[100005];

/**
 * 计算 n!中质因子 x 的数量
 * @param n
 * @param x
 * @return
 */
long long calc(long long n, long long x) {
    long long num = 0;
    while (n) {
        num += n / x;
        n = n / x;
    }
    return num;
}

void solve(int n, long long x, long long y) {
    factor_nums.clear();
    // c好像也能取2307
    find_factor(x, rand() % (n - 1) + 1);
    long long ans = 1LL << 61;
    for (auto &i : factor_nums) {
        long long z_factor_nums = 0;
        for (int j = 0; j < n; ++j) {
            z_factor_nums += calc(arr[j], i.first);
        }
        long long y_factor_nums = calc(y, i.first);
        ans = std::min(ans, (y_factor_nums - z_factor_nums) / i.second);
    }
    printf("%lld\n", ans);
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n;
        long long x, y;
        scanf("%d %lld %lld", &n, &x, &y);
        for (int i = 0; i < n; ++i) {
            scanf("%lld", arr + i);
        }
        solve(n, x, y);
    }
    return 0;
}
```

