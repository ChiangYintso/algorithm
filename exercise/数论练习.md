# 数论练习

[TOC]

## GCD、LCM

https://www.luogu.com.cn/problem/P1414

从n个数中取出1、2、3、...、n个数，使其gcd最大。

解：求出每个因数出现的次数，并对每个次数记录最大的因数。

```c++
#include <cstdio>

int arr[100009];
int prime_count[1000009] = {0};
int answer[1000009] = {0};

inline int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", arr + i);
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 1; j * j <= arr[i]; ++j) {
            if (arr[i] % j == 0) {
                prime_count[j]++;
                answer[prime_count[j]] = max(answer[prime_count[j]], j);
                if (j * j < arr[i]) {
                    prime_count[arr[i] / j]++;
                    answer[prime_count[arr[i] / j]] = max(answer[prime_count[arr[i] / j]], arr[i] / j);
                }
            }
        }
    }

    for (int i = 1; i <= n; ++i)
        printf("%d\n", answer[i]);

    return 0;
}

```

**hdu5656 求n个数所有挑选组合的gcd之和（gcd+dp）**

```c++
//
// Created by Jiang Yinzuo on 2020/7/17.
//

#include <cstdio>
#include <algorithm>
#include <cstring>

const int MOD = 100000007;
long long dp[1001][1001];
int arr[1001];
int gcd[1001][1001] = {0};

void get_gcd(int n, int m) {
    for (int i = 1; i <= 1000; ++i) {
        for (int j = 1; j <= 1000; ++j) {
            if (!gcd[i][j]) {
                for (int k = 1; k * i <= n && k * j <= m; ++k) {
                    gcd[k * i][k * j] = k;
                }
            }
        }
    }
}

void solve(int n, int max_gcd) {
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= n; ++i) {
        dp[i][arr[i]] = 1;
        for (int j = 1; j <= max_gcd; ++j) {
            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;
            dp[i][gcd[arr[i]][j]] = (dp[i][gcd[arr[i]][j]] + dp[i - 1][j]) % MOD;
        }
    }

    long long answer = 0;
    for (int i = 1; i <= max_gcd; ++i) {
        answer = (answer + dp[n][i] * i) % MOD;
    }
    printf("%lld\n", answer);
}

int main() {
    get_gcd(1000, 1000);
    int t;
    scanf("%d", &t);
    while (t--) {
        int n;
        scanf("%d", &n);
        int max_gcd = 0;
        for (int i = 1; i <= n; ++i) {
            scanf("%d", arr + i);
            max_gcd = std::max(max_gcd, arr[i]);
        }
        solve(n, max_gcd);
    }
    return 0;
}

```



**cf1366D 对正整数a，找到a的大于1的因数b，c使得$$\gcd(b+c,a)=1$$**

解：若$$\gcd(b, c) = g > 1$$，则$$b+c和a$$至少有g这个公因数。故仅当存在$$\gcd(b, c) = 1$$时，问题有解。

$$gcd(b, c) = 1 \iff gcd(b+c, c) = 1 \iff gcd(b+c,b) = 1 \iff \gcd(b+c, cb^k) = 1$$。故找到a的最小质因数$$p$$（提前打表），解为$$b = p^k, c = \frac{a}{p^k}, c\bmod b \neq 0 $$

```c++
//
// Created by Jiang Yinzuo on 2020/7/23.
//

#include <vector>
#include <cstdio>

int min_prime[10000007] = {0};

void get_min_prime_factor() {
    for (int i = 2; i <= 3163; ++i) {
        if (min_prime[i] == 0) {
            for (int j = i * 2; j <= 10000000; j += i) {
                if (min_prime[j] == 0)
                    min_prime[j] = i;
            }
        }
    }
}

std::vector<int> b_ans, c_ans;

void solve(int a) {
    if (min_prime[a] == 0) {
        b_ans.push_back(-1);
        c_ans.push_back(-1);
        return;
    }
    int c = a;
    while (c % min_prime[a] == 0) {
        c /= min_prime[a];
    }
    if (c > 1) {
        b_ans.push_back(min_prime[a]);
        c_ans.push_back(c);
    } else {
        b_ans.push_back(-1);
        c_ans.push_back(-1);
    }
}

int main() {
    get_min_prime_factor();
    int n;
    scanf("%d", &n);
    int a;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a);
        solve(a);
    }
    for (auto &i : b_ans) {
        printf("%d ", i);
    }
    puts("");
    for (auto &i : c_ans) {
        printf("%d ", i);
    }
    puts("");
    return 0;
}
```



## 因数个数定理

**hdu6069**：求
$$
(∑\limits_{i=l}^rd(i^k)) \bmod998244353 \space \space \space (1≤l≤r≤10^{12},r−l≤10^6,1≤k≤10^7).
$$
$$d(x)$$表示x的因数个数。

显然，1e6以上的质数最多存在一个。故先打表得到1-1e6之间的质数。枚举1-1e6中的每个质数。根据该质数在【l, r】中的出现的次数更新$$d(i^k)$$，并将i /= 质数。质数^2大于r时停止遍历。

```c++
//
// Created by Jiang Yinzuo on 2020/7/17.
//

#include <cstdio>
#include <vector>
#include <cstring>

const int MOD = 998244353;
bool is_prime[1000006];
std::vector<int> primes;

void sieve(int n) {
    memset(is_prime, true, sizeof(is_prime));
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i + i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

void solve(long long l, long long r, long long k) {
    static long long num[1000006];
    static long long factor_count[1000006];
    for (long long i = l; i <= r; ++i) {
        num[i - l] = i;
        factor_count[i - l] = 1;
    }

    for (auto &prime : primes) {
        if (prime * prime > r) break;
        long long i = (long long) (l / prime) * prime;
        while (i < l) i += prime;
        for (; i <= r; i += prime) {
            long long count = 0;
            while (num[i - l] % prime == 0) {
                num[i - l] /= prime;
                count++;
            }
            factor_count[i - l] = factor_count[i - l] * (count * k + 1) % MOD;
        }
    }

    long long answer = 0;
    for (long long i = l; i <= r; ++i) {
        if (num[i - l] == 1)
            answer = (answer + factor_count[i - l]) % MOD;
        else answer = (answer + factor_count[i - l] * (k + 1) % MOD) % MOD;
    }
    printf("%lld\n", answer);
}

int main() {
    sieve(1000005);
    int t;
    scanf("%d", &t);
    while (t--) {
        long long l, r, k;
        scanf("%lld %lld %lld", &l, &r, &k);
        solve(l, r, k);
    }
    return 0;
}

```

